(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{423:function(e,r,o){"use strict";o.r(r);var t=o(17),a=Object(t.a)({},(function(){var e=this,r=e.$createElement,o=e._self._c||r;return o("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[o("h1",{attrs:{id:"sealing-process"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#sealing-process"}},[e._v("#")]),e._v(" Sealing Process")]),e._v(" "),o("p",[e._v("In a nutshell the process is splitted into 4 phases:")]),e._v(" "),o("ol",[o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/fba94e039c140698fef692ba5399c925b9b31acf/src/seal.rs#L334",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seal_pre_commit_phase1")]),o("OutboundLink")],1),e._v("(PC1)\n"),o("ol",[o("li",[e._v("The sector data is first copied as the sealed sector file "),o("code",[e._v("replica")]),e._v("(which is further updated during PC2), then stored as leaves of a merkle tree, resulting in the merkle tree "),o("code",[e._v("tree_d")]),e._v(" and the merkle root "),o("code",[e._v("comm_d")]),e._v(".")]),e._v(" "),o("li",[e._v("The miner derives a unique "),o("code",[e._v("replica_id")]),e._v(" for the current sealing sector.")]),e._v(" "),o("li",[e._v("A layered structure called "),o("code",[e._v("StackedDrg")]),e._v(" that has the same number of nodes in each layer as "),o("code",[e._v("#leaves")]),e._v(" of "),o("code",[e._v("tree_d")]),e._v(", is labeled based on "),o("code",[e._v("replica_id")]),e._v(", resulting in layered "),o("code",[e._v("labels")]),e._v(".")])])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/fba94e039c140698fef692ba5399c925b9b31acf/src/seal.rs#L416",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seal_pre_commit_phase2")]),o("OutboundLink")],1),e._v("(PC2)\n"),o("ol",[o("li",[e._v("The layered "),o("code",[e._v("labels")]),e._v(" are first aggregated into column commitments, then the column commitments are stored as leaves of a merkle tree, resulting in the merkle tree "),o("code",[e._v("tree_c")]),e._v(" and the merkle root "),o("code",[e._v("tree_c_root")]),e._v(".")]),e._v(" "),o("li",[e._v("The labels of the last layer are used as the keys for encoding the leaves of "),o("code",[e._v("tree_d")]),e._v(", the encoding results are first stored in the sealed sector file "),o("code",[e._v("replica")]),e._v(", then stored as leaves of a merkle tree, resulting in the merkle tree "),o("code",[e._v("tree_r_last")]),e._v(" and the merkle root "),o("code",[e._v("tree_r_last_root")]),e._v(".")]),e._v(" "),o("li",[o("code",[e._v("tree_c_root")]),e._v(" and "),o("code",[e._v("tree_r_last_root")]),e._v(" are further hashed into "),o("code",[e._v("comm_r")]),e._v(".")])])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/fba94e039c140698fef692ba5399c925b9b31acf/src/seal.rs#L508",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seal_commit_phase1")]),o("OutboundLink")],1),e._v("(C1)\n"),o("ol",[o("li",[e._v("The idea is that, in order to prove that the miner actually stored the sector data, the miner has to come up with the merkle proofs of randomly challenged leaves of the above mentioned trees.")]),e._v(" "),o("li",[e._v("The challenge is derived after "),o("code",[e._v("tree_d")]),e._v(" and "),o("code",[e._v("tree_r_last")]),e._v(" are committed(from the beacon chain randomness of height "),o("a",{attrs:{href:"https://github.com/filecoin-project/builtin-actors/blob/f28bfd0339ea51479efc5697eefffaddf5e9c244/actors/miner/src/lib.rs#L891",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("precommit.pre_commit_epoch + rt.policy().pre_commit_challenge_delay")]),o("OutboundLink")],1),e._v("), conforming to the "),o("code",[e._v("commit/challenge/response")]),e._v(" scheme.")]),e._v(" "),o("li",[e._v("The challenge is divided into some specific number of partitions(basically some hardcoded rounds of challenges, where each round challenges several nodes from various trees above), the actual number is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/fba94e039c140698fef692ba5399c925b9b31acf/src/registry.rs#L122",target:"_blank",rel:"noopener noreferrer"}},[e._v("decided"),o("OutboundLink")],1),e._v(" by the sector size.")]),e._v(" "),o("li",[e._v("A single partition proof shows that:\n"),o("ol",[o("li",[e._v("The prover knows valid merkle paths for the challenged leaves in "),o("code",[e._v("tree_d")]),e._v(" that is consistent with "),o("code",[e._v("comm_d")]),e._v(".")]),e._v(" "),o("li",[e._v("The prover knows valid merkle paths for the challenged leaves in "),o("code",[e._v("tree_c")]),e._v(" and "),o("code",[e._v("tree_r_last")]),e._v(" which are consistent with "),o("code",[e._v("comm_r")]),e._v(".")]),e._v(" "),o("li",[e._v("The prover knows the challenged label and its parents' labels in each "),o("code",[e._v("StackedDrg")]),e._v(" layer.")]),e._v(" "),o("li",[e._v("The prover knows the challenged label and its parents' labels in the last "),o("code",[e._v("StackedDrg")]),e._v(" layer, which are used as encoding key.")])])])])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/fba94e039c140698fef692ba5399c925b9b31acf/src/seal.rs#L600",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("seal_commit_phase2")]),o("OutboundLink")],1),e._v("(C2)\n"),o("ol",[o("li",[e._v("As the above proof is quite big, the purpose of this phase is to convert the above proofs into zkSNARK proofs, which will be small.")]),e._v(" "),o("li",[e._v("After "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L206",target:"_blank",rel:"noopener noreferrer"}},[e._v("all"),o("OutboundLink")],1),e._v(" the public input are specified, the private witness and constraints are synthesized, with the help of setup parameters.")]),e._v(" "),o("li",[e._v("Finally the public input plus the "),o("code",[e._v("A/B/C")]),e._v(" as specified in the groth16 protocol are verified onchain as witness proof to show the miner can answer all challenges, thus must have stored the whole sector with great possibility.")])])])]),e._v(" "),o("p",[e._v("The details of each phase are explained below.")]),e._v(" "),o("h2",{attrs:{id:"pc1"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pc1"}},[e._v("#")]),e._v(" PC1")]),e._v(" "),o("p",[e._v("The purpose of this phase is to generate "),o("code",[e._v("replica")]),e._v(", "),o("code",[e._v("tree_d")]),e._v(", and "),o("code",[e._v("labels")]),e._v(" mentioned above.")]),e._v(" "),o("p",[o("code",[e._v("tree_d")]),e._v(" is generated as follows:")]),e._v(" "),o("ol",[o("li",[e._v("The sector data file is first "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/seal.rs#L92",target:"_blank",rel:"noopener noreferrer"}},[e._v("copied as sealed sector file"),o("OutboundLink")],1),e._v(", "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/seal.rs#L107",target:"_blank",rel:"noopener noreferrer"}},[e._v("padding"),o("OutboundLink")],1),e._v(" if needed.")]),e._v(" "),o("li",[e._v("Then a binary merkle tree is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/seal.rs#L153",target:"_blank",rel:"noopener noreferrer"}},[e._v("created"),o("OutboundLink")],1),e._v(" based on leaves.\n"),o("ol",[o("li",[e._v("Some notations: "),o("code",[e._v("tree_size")]),e._v(" = "),o("code",[e._v("#leaf")]),e._v(" + "),o("code",[e._v("#internal_node")]),e._v(".")]),e._v(" "),o("li",[e._v("Then "),o("code",[e._v("#leaf")]),e._v(" = "),o("code",[e._v("sector_size")]),e._v("/"),o("code",[e._v("size_of(domain)")]),e._v(", as per "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/util.rs#L31",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("Then "),o("code",[e._v("tree_size")]),e._v(" is calculated from "),o("code",[e._v("#leaf")]),e._v(" "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/util.rs#L35",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(", basically the size for each layer shrinks by a factor of 2 until 1, then sum up all layers.")]),e._v(" "),o("li",[e._v("Every 32 bytes of leaf data is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/merkle/builders.rs#L211",target:"_blank",rel:"noopener noreferrer"}},[e._v("converted"),o("OutboundLink")],1),e._v(" into a domain element.")]),e._v(" "),o("li",[e._v("Then each leaf element is "),o("a",{attrs:{href:"https://github.com/filecoin-project/merkletree/blob/a81abcf3854f96c08de0aada69e597daf11aa757/src/merkle.rs#L2074",target:"_blank",rel:"noopener noreferrer"}},[e._v("concatenated"),o("OutboundLink")],1),e._v(", then persisted on disk.\n"),o("ol",[o("li",[e._v("There's a trick here, "),o("code",[e._v("a.leaf(item)")]),e._v(" actually does nothing for "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/d8199051e4bed44e427b02b9b90277c21482943c/filecoin-hashers/src/sha256.rs#L289-L291",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("Algorithm<Sha256Domain>")]),o("OutboundLink")],1),e._v(" and "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/d8199051e4bed44e427b02b9b90277c21482943c/filecoin-hashers/src/poseidon.rs#L318-L320",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("LightAlgorithm<PoseidonDomain>")]),o("OutboundLink")],1),e._v(", the "),o("a",{attrs:{href:"https://github.com/filecoin-project/merkletree/blob/a81abcf3854f96c08de0aada69e597daf11aa757/src/hash.rs#L129",target:"_blank",rel:"noopener noreferrer"}},[e._v("default implementation"),o("OutboundLink")],1),e._v(" is never triggered.")])])]),e._v(" "),o("li",[e._v("From the leaf nodes, the internal nodes are then "),o("a",{attrs:{href:"https://github.com/filecoin-project/merkletree/blob/a81abcf3854f96c08de0aada69e597daf11aa757/src/merkle.rs#L1633",target:"_blank",rel:"noopener noreferrer"}},[e._v("built"),o("OutboundLink")],1),e._v(" layer by layer from the bottom to top.")]),e._v(" "),o("li",[e._v("The resulting merkle tree is stored under the cache path with "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/cache_key.rs#L17",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("tree-d")]),o("OutboundLink")],1),e._v(" in its name.")])])])]),e._v(" "),o("p",[o("code",[e._v("labels")]),e._v(" is generated as follows:")]),e._v(" "),o("ol",[o("li",[e._v("The "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/proof.rs#L9",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("ProofScheme")]),o("OutboundLink")],1),e._v(" for the sealing process is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof_scheme.rs#L16",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("StackedDrg")]),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("First the "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/params.rs#L53",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("PublicParams")]),o("OutboundLink")],1),e._v(" for "),o("code",[e._v("StackedDrg")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof_scheme.rs#L26",target:"_blank",rel:"noopener noreferrer"}},[e._v("setup"),o("OutboundLink")],1),e._v(", which includes "),o("code",[e._v("StackedBucketGraph")]),e._v(" and "),o("code",[e._v("LayerChallenges")]),e._v(", triggered "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/seal.rs#L129",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(".\n"),o("ol",[o("li",[o("code",[e._v("StackedBucketGraph")]),e._v(" is an "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/graph.rs#L61",target:"_blank",rel:"noopener noreferrer"}},[e._v("alias"),o("OutboundLink")],1),e._v(" for "),o("code",[e._v("StackedGraph<H, BucketGraph<H>>")]),e._v(", a layered graph with the same number of nodes in each layer as "),o("code",[e._v("#leaves")]),e._v(" in "),o("code",[e._v("tree_d")]),e._v(", the actual "),o("code",[e._v("#layer")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/constants.rs#L108",target:"_blank",rel:"noopener noreferrer"}},[e._v("decided"),o("OutboundLink")],1),e._v(" by sector size.")]),e._v(" "),o("li",[e._v("The core function of this structure is for easily generating base parents and expander parents for nodes.\n"),o("ol",[o("li",[e._v("For base parents(parents in the same layer), it "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/graph.rs#L418",target:"_blank",rel:"noopener noreferrer"}},[e._v("delegates"),o("OutboundLink")],1),e._v(" the the work to the "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/drgraph.rs#L138",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("BucketGraph::parents")]),o("OutboundLink")],1),e._v(" directly.\n"),o("ol",[o("li",[e._v("Basically this function randomly but deterministically("),o("code",[e._v("seed")]),e._v(" is given) chooses nodes with smaller index as parents, but guarantees that the immediate predecessor is among them so that labels can only be computed sequentially.")])])]),e._v(" "),o("li",[e._v("For expander parents(parents in the previous layer), it calls "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/128f7209ec583e023f04630102ef1dd17fbe2370/storage-proofs-porep/src/stacked/vanilla/graph.rs#L341",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("correspondent")]),o("OutboundLink")],1),e._v(" to compute parents one by one, basically using feistel encoding to randomly but deterministically choose nodes with smaller index.")]),e._v(" "),o("li",[e._v("Both base parents and expander parents may contain duplicate nodes.")])])])])]),e._v(" "),o("li",[e._v("Then a unique "),o("code",[e._v("replica_id")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/api/seal.rs#L176",target:"_blank",rel:"noopener noreferrer"}},[e._v("generated"),o("OutboundLink")],1),e._v(" for the current sealing sector.")]),e._v(" "),o("li",[e._v("Then the layered labels for "),o("code",[e._v("StackedDrg")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/963eb08e55b9700657d8533418bf6332ac77d197/storage-proofs-porep/src/stacked/vanilla/proof.rs#L328",target:"_blank",rel:"noopener noreferrer"}},[e._v("generated"),o("OutboundLink")],1),e._v(" based on "),o("code",[e._v("PublicParams")]),e._v(" and "),o("code",[e._v("replica_id")]),e._v(".\n"),o("ol",[o("li",[e._v("For the first layer, each node only has base parents, "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/create_label/single.rs#L173",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("create_label")]),o("OutboundLink")],1),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/create_label/single.rs#L54",target:"_blank",rel:"noopener noreferrer"}},[e._v("called"),o("OutboundLink")],1),e._v(" to generate labels for each node.\n"),o("ol",[o("li",[e._v("The final node label is computed from "),o("code",[e._v("sha256(layer index, node index, replica id, all base parents)")])]),e._v(" "),o("li",[e._v("The base parents are hashed for "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/128f7209ec583e023f04630102ef1dd17fbe2370/storage-proofs-porep/src/stacked/vanilla/graph.rs#L242",target:"_blank",rel:"noopener noreferrer"}},[e._v("7 rounds"),o("OutboundLink")],1),e._v(".")])])]),e._v(" "),o("li",[e._v("For all other layers, each node has both base parents and expander parents, "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/d8199051e4bed44e427b02b9b90277c21482943c/storage-proofs-porep/src/stacked/vanilla/create_label/single.rs#L210",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("create_label_exp")]),o("OutboundLink")],1),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/d8199051e4bed44e427b02b9b90277c21482943c/storage-proofs-porep/src/stacked/vanilla/create_label/single.rs#L65",target:"_blank",rel:"noopener noreferrer"}},[e._v("called"),o("OutboundLink")],1),e._v(" to generate labels for each node.\n"),o("ol",[o("li",[e._v("The final node label is computed from "),o("code",[e._v("sha256(layer index, node index, replica id, all base and expander parents)")])]),e._v(" "),o("li",[e._v("The base and expander parents are hashed for "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/128f7209ec583e023f04630102ef1dd17fbe2370/storage-proofs-porep/src/stacked/vanilla/graph.rs#L213",target:"_blank",rel:"noopener noreferrer"}},[e._v("3 rounds"),o("OutboundLink")],1),e._v(".")])])]),e._v(" "),o("li",[e._v("The resulting labels of each layer are stored separately under the cache path with "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/create_label/mod.rs#L26",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("layer-N")]),o("OutboundLink")],1),e._v(" in its name.")])])])]),e._v(" "),o("h2",{attrs:{id:"pc2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#pc2"}},[e._v("#")]),e._v(" PC2")]),e._v(" "),o("p",[e._v("The purpose of this phase is to generate "),o("code",[e._v("tree_c")]),e._v(" and "),o("code",[e._v("tree_r_last")]),e._v(" mentioned above, and update the sealed sector file "),o("code",[e._v("replica")]),e._v(" with preimages of leaves of "),o("code",[e._v("tree_r_last")]),e._v(".")]),e._v(" "),o("p",[o("code",[e._v("tree_c")]),e._v(" is generated as follows:")]),e._v(" "),o("ol",[o("li",[e._v("The shape of "),o("code",[e._v("tree_c")]),e._v(" is not vanilla binary merkle tree, but "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/filecoin-proofs/src/constants.rs#L223",target:"_blank",rel:"noopener noreferrer"}},[e._v("decided"),o("OutboundLink")],1),e._v(" by sector size, basically it's a 3-layered merkle tree: base tree -> sub tree -> top tree, where each tree can have different arity(branches).\n"),o("ol",[o("li",[e._v("For 32GB sector, the shape is "),o("code",[e._v("(U8, U8, U0)")]),e._v(", meaning the base tree arity is 8, sub tree arity is also 8, but there's no top tree.")]),e._v(" "),o("li",[e._v("For 64GB sector, the shape is "),o("code",[e._v("(U8, U8, U2)")]),e._v(", meaning the base tree arity is 8, sub tree arity is also 8, and the top tree arity is 2.")]),e._v(" "),o("li",[e._v("The max height for top tree and sub tree is 1, so that the base tree count can be computed like "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/merkle/builders.rs#L374",target:"_blank",rel:"noopener noreferrer"}},[e._v("this"),o("OutboundLink")],1),e._v(", resulting in "),o("code",[e._v("tree_count")]),e._v(".")])])]),e._v(" "),o("li",[e._v("The "),o("code",[e._v("node_count")]),e._v(" for base tree is computed by "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L1285",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("graph.size() / tree_count")]),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("Imagine the layered "),o("code",[e._v("StackedGraph")]),e._v(" mentioned above, it's cut into chunks of width "),o("code",[e._v("node_count")]),e._v(" vertically, then for each chunk, the nodes of the same column are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L813",target:"_blank",rel:"noopener noreferrer"}},[e._v("hashed"),o("OutboundLink")],1),e._v(" into a single value, resulting in "),o("code",[e._v("node_count")]),e._v(" hash values. These "),o("code",[e._v("node_count")]),e._v(" hash values are then used as leaves to "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L821",target:"_blank",rel:"noopener noreferrer"}},[e._v("build"),o("OutboundLink")],1),e._v(" the base merkle tree.")]),e._v(" "),o("li",[e._v("In total, the above step generates "),o("code",[e._v("tree_count")]),e._v(" base merkle trees, which are then "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L830",target:"_blank",rel:"noopener noreferrer"}},[e._v("aggregated"),o("OutboundLink")],1),e._v(" into the 3-layered merkle tree.")])]),e._v(" "),o("p",[o("code",[e._v("tree_r_last")]),e._v(" is generated as follows:")]),e._v(" "),o("ol",[o("li",[o("code",[e._v("labels")]),e._v(" of the last layer are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L1413",target:"_blank",rel:"noopener noreferrer"}},[e._v("used as encoding keys"),o("OutboundLink")],1),e._v(" for the replica.")]),e._v(" "),o("li",[e._v("Then "),o("code",[e._v("tree_r_last")]),e._v(" is generated in a similar fasion as "),o("code",[e._v("tree_c")]),e._v(" except that each element is computed by "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L897",target:"_blank",rel:"noopener noreferrer"}},[e._v("combining"),o("OutboundLink")],1),e._v(" corresponding elements of sector data and label data of the last layer, the preimages of leaves are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L899",target:"_blank",rel:"noopener noreferrer"}},[e._v("stored in-place"),o("OutboundLink")],1),e._v(" in the sealed sector file "),o("code",[e._v("replica")]),e._v(".")])]),e._v(" "),o("p",[e._v("The roots of "),o("code",[e._v("tree_c")]),e._v(" and "),o("code",[e._v("tree_r_last")]),e._v(" are then "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L1437",target:"_blank",rel:"noopener noreferrer"}},[e._v("hashed"),o("OutboundLink")],1),e._v(" into "),o("code",[e._v("comm_r")]),e._v(".")]),e._v(" "),o("h2",{attrs:{id:"c1"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#c1"}},[e._v("#")]),e._v(" C1")]),e._v(" "),o("p",[e._v("The purpose of this phase is to generate proofs for all challenges.")]),e._v(" "),o("p",[e._v("The process is as follows:")]),e._v(" "),o("ol",[o("li",[e._v("The proofs are computed partition by partition.")]),e._v(" "),o("li",[e._v("For each partition, all challenged leaf indices are computed "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L154",target:"_blank",rel:"noopener noreferrer"}},[e._v("in a batch"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("For each challenged leaf index "),o("code",[e._v("c")]),e._v(":\n"),o("ol",[o("li",[e._v("The merkle proof of leaf "),o("code",[e._v("c")]),e._v(" in "),o("code",[e._v("tree_d")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L166",target:"_blank",rel:"noopener noreferrer"}},[e._v("computed"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("All labels of index "),o("code",[e._v("c")]),e._v(" are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L177",target:"_blank",rel:"noopener noreferrer"}},[e._v("fetched and converted"),o("OutboundLink")],1),e._v(" into a column proof of "),o("code",[e._v("tree_c")]),e._v(".")]),e._v(" "),o("li",[e._v("All base parents of node "),o("code",[e._v("c")]),e._v(" are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L181",target:"_blank",rel:"noopener noreferrer"}},[e._v("fetched and converted"),o("OutboundLink")],1),e._v(" into a column proof of "),o("code",[e._v("tree_c")]),e._v(".")]),e._v(" "),o("li",[e._v("All expander parents of node "),o("code",[e._v("c")]),e._v(" are "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L188",target:"_blank",rel:"noopener noreferrer"}},[e._v("fetched and converted"),o("OutboundLink")],1),e._v(" into a column proof of "),o("code",[e._v("tree_c")]),e._v(".")]),e._v(" "),o("li",[e._v("The merkle proof of leaf "),o("code",[e._v("c")]),e._v(" in "),o("code",[e._v("tree_r_last")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L205",target:"_blank",rel:"noopener noreferrer"}},[e._v("computed"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("For each layer:\n"),o("ol",[o("li",[e._v("The parent labels are challenged node "),o("code",[e._v("c")]),e._v(" are fetched and "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/vanilla/proof.rs#L248",target:"_blank",rel:"noopener noreferrer"}},[e._v("repeated"),o("OutboundLink")],1),e._v(" as "),o("code",[e._v("LabelingProof")]),e._v(".")]),e._v(" "),o("li",[e._v("The "),o("code",[e._v("LabelingProof")]),e._v(" of the last layer is redundantly saved as "),o("code",[e._v("EncodingProof")]),e._v(".")])])])])])]),e._v(" "),o("h2",{attrs:{id:"c2"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#c2"}},[e._v("#")]),e._v(" C2")]),e._v(" "),o("p",[e._v("The purpose of this phase is to make the above proofs succinct using zkSNARK circuit(groth16 circuit actually).")]),e._v(" "),o("p",[e._v("Central to the circuit is the "),o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/constraint_system.rs#L71",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("ConstraintSystem")]),o("OutboundLink")],1),e._v(" trait:")]),e._v(" "),o("ol",[o("li",[o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/constraint_system.rs#L99",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("alloc_input")]),o("OutboundLink")],1),e._v(" is called to allocate a public input.")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/constraint_system.rs#L91",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("alloc")]),o("OutboundLink")],1),e._v(" is called to allocate a private witness.")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/constraint_system.rs#L107",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("enforce")]),o("OutboundLink")],1),e._v(" is called to enforce a constraint of the form "),o("code",[e._v("A * B = C")]),e._v(".")])]),e._v(" "),o("p",[e._v("The process is as follows:")]),e._v(" "),o("ol",[o("li",[e._v("For "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/compound_proof.rs#L245",target:"_blank",rel:"noopener noreferrer"}},[e._v("each"),o("OutboundLink")],1),e._v(" partition proof, "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L288",target:"_blank",rel:"noopener noreferrer"}},[e._v("construct"),o("OutboundLink")],1),e._v(" an instance of "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L28",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("StackedCircuit")]),o("OutboundLink")],1),e._v(".\n"),o("ol",[o("li",[e._v("Internally the partition proof is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L320",target:"_blank",rel:"noopener noreferrer"}},[e._v("converted"),o("OutboundLink")],1),e._v(" into challenge proofs.")])])]),e._v(" "),o("li",[e._v("The logic to process groth16 circuit is common(in fact the original author of "),o("code",[e._v("bellman")]),e._v(" is planning to move it into a separate crate in the future):\n"),o("ol",[o("li",[e._v("Generate two random variables "),o("code",[e._v("r")]),e._v(" and "),o("code",[e._v("s")]),e._v(" "),o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/groth16/prover.rs#L235",target:"_blank",rel:"noopener noreferrer"}},[e._v("nondeterministically"),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("Each circuit is synthesized in a batch via "),o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/groth16/prover.rs#L648",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("synthesize_circuits_batch")]),o("OutboundLink")],1),e._v(".\n"),o("ol",[o("li",[e._v("The first public input is "),o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/groth16/prover.rs#L669",target:"_blank",rel:"noopener noreferrer"}},[e._v("always "),o("code",[e._v("1")]),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("Then "),o("a",{attrs:{href:"https://github.com/zhiqiangxu/bellperson/blob/42b3aa8a34bedbeb3145729882a671635cb288fb/src/groth16/prover.rs#L671",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("circuit::synthesize")]),o("OutboundLink")],1),e._v(" is called to generate all assignments and constraints.")]),e._v(" "),o("li",[e._v("The "),o("code",[e._v("A/B/C")]),e._v(" polynomial evaluations as specified in the groth16 paper and assignments for public input and witness are returned for further processing.")])])]),e._v(" "),o("li",[e._v("A bunch of tricks are further carried out to extract a proof as specified in the groth16 paper.")])])])]),e._v(" "),o("h3",{attrs:{id:"arithmetization"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#arithmetization"}},[e._v("#")]),e._v(" Arithmetization")]),e._v(" "),o("p",[e._v("The process of converting general computation to circuit is called arithmetization, which is pretty complicated in the general case (e.g. zkevm), but much easier for a specific computation, like sealing, and it's more relevant for developers actually writing circuits, so it's worth to dive into the details of "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L92",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("StackedCircuit::synthesize")]),o("OutboundLink")],1),e._v(":")]),e._v(" "),o("ol",[o("li",[e._v("A witness for "),o("code",[e._v("replica_id")]),e._v(" is allocated, which is then constrained to be equal to a input.")]),e._v(" "),o("li",[e._v("Then the "),o("code",[e._v("replica_id")]),e._v(" witness is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L114",target:"_blank",rel:"noopener noreferrer"}},[e._v("converted"),o("OutboundLink")],1),e._v(" to bit witness of size "),o("code",[e._v("Scalar::NUM_BITS")]),e._v("(required by "),o("a",{attrs:{href:"https://github.com/filecoin-project/bellperson/blob/950829bba6504a806958877451480ef597d6bd73/src/gadgets/sha256.rs#L50",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("sha256 circuit")]),o("OutboundLink")],1),e._v(", "),o("a",{attrs:{href:"https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),o("OutboundLink")],1),e._v(" for specification).")]),e._v(" "),o("li",[e._v("A witness for "),o("code",[e._v("comm_d")]),e._v(" is allocated and assigned, which is then constrained to be equal to a input.")]),e._v(" "),o("li",[e._v("A witness for "),o("code",[e._v("comm_r")]),e._v(" is allocated and assigned, which is then constrained to be equal to a input.")]),e._v(" "),o("li",[e._v("A witness for "),o("code",[e._v("comm_r_last")]),e._v(" is allocated and assigned.")]),e._v(" "),o("li",[e._v("A witness for "),o("code",[e._v("comm_c")]),e._v(" is allocated and assigned.")]),e._v(" "),o("li",[o("code",[e._v("comm_r")]),e._v(" is computed and saved in another witness via "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L153",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("hash2_circuit(comm_c, comm_r_last)")]),o("OutboundLink")],1),e._v(" and constrained to be equal to the public input "),o("code",[e._v("comm_r")]),e._v(".")]),e._v(" "),o("li",[e._v("Then for each challenge proof, "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/proof.rs#L169",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("Proof::synthesize")]),o("OutboundLink")],1),e._v(" is called to generate a subcircuit.\n"),o("ol",[o("li",[o("code",[e._v("data_leaf")]),e._v(" opening:\n"),o("ol",[o("li",[e._v("A witness for "),o("code",[e._v("data_leaf")]),e._v(" is allocated and assigned.")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L130",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("enforce_inclusion")]),o("OutboundLink")],1),e._v(" is called to ensure existence of "),o("code",[e._v("data_leaf")]),e._v(" in "),o("code",[e._v("comm_d")]),e._v(", essentially an arithmetization for merkle leaf inclusion proof.")])])]),e._v(" "),o("li",[o("code",[e._v("replica column")]),e._v(" opening:\n"),o("ol",[o("li",[e._v("For each base/expander parent column:\n"),o("ol",[o("li",[e._v("A witness is allocated and assigned for each node in the column, then "),o("a",{attrs:{href:"https://github.com/filecoin-project/neptune/blob/5abfd12ae72f19d7a2a491307e51b3bef2c95214/src/circuit.rs#L376",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("poseidon_hash")]),o("OutboundLink")],1),e._v(" is called to allocate and assign the "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L148",target:"_blank",rel:"noopener noreferrer"}},[e._v("column hash witness"),o("OutboundLink")],1),e._v(", resulting in "),o("code",[e._v("val")]),e._v(".")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L130",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("enforce_inclusion")]),o("OutboundLink")],1),e._v(" is called to ensure existence of "),o("code",[e._v("val")]),e._v(" in "),o("code",[e._v("comm_c")]),e._v(".")])])])])]),e._v(" "),o("li",[e._v("A witness for "),o("code",[e._v("challenge")]),e._v(" is allocated and assigned, which is then "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L186",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("pack_into_input")]),o("OutboundLink")],1),e._v(".")]),e._v(" "),o("li",[e._v("labeling opening:\n"),o("ol",[o("li",[e._v("For each layer, the labeling is verified:\n"),o("ol",[o("li",[e._v("Parent labels are converted and constrained into bit values, and then duplicated according to the hashing algorithm.\n"),o("ol",[o("li",[e._v("The reason for this step is that the "),o("a",{attrs:{href:"https://github.com/filecoin-project/bellperson/blob/950829bba6504a806958877451480ef597d6bd73/src/gadgets/sha256.rs#L50",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("sha256 circuit")]),o("OutboundLink")],1),e._v(" expects the input to be in this form.")])])]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L235",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("create_label_circuit")]),o("OutboundLink")],1),e._v(" is called to actually allocate and assign the label for the challenged node, resulting in "),o("code",[e._v("label")]),e._v(".\n"),o("ol",[o("li",[o("code",[e._v("create_label_circuit")]),e._v(" prepares the input for "),o("code",[e._v("sha256 circuit")]),e._v(", pads with "),o("code",[e._v("false")]),e._v(" if necesary, then calls "),o("code",[e._v("sha256 circuit")]),e._v(" to do the heavy part.")])])])])]),e._v(" "),o("li",[e._v("Each layer's "),o("code",[e._v("label")]),e._v(" is stored into "),o("code",[e._v("column_labels")]),e._v(", and finally "),o("code",[e._v("column_hash")]),e._v(" is computed from "),o("code",[e._v("column_labels")]),e._v(" via "),o("code",[e._v("poseidon_hash")]),e._v(" and ensured to exist in "),o("code",[e._v("comm_c")]),e._v(" via "),o("code",[e._v("enforce_inclusion")]),e._v(".")])])]),e._v(" "),o("li",[e._v("encoding node opening:\n"),o("ol",[o("li",[e._v("The label of of last layer is used as encoding key to encode the above "),o("code",[e._v("data_leaf")]),e._v(", resulting in "),o("code",[e._v("encoded_node")]),e._v(".")]),e._v(" "),o("li",[o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-porep/src/stacked/circuit/params.rs#L130",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("enforce_inclusion")]),o("OutboundLink")],1),e._v(" is called to ensure existence of "),o("code",[e._v("encoded_node")]),e._v(" in "),o("code",[e._v("comm_r_last")]),e._v(".")])])])])])]),e._v(" "),o("p",[e._v("So by here we can see that circuit is composed of assignments and constraints, and how the circuit for sealing is actually spelled out.")]),e._v(" "),o("h2",{attrs:{id:"verify"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#verify"}},[e._v("#")]),e._v(" Verify")]),e._v(" "),o("p",[e._v("The entry point of proof verification is "),o("a",{attrs:{href:"https://github.com/filecoin-project/ref-fvm/blob/146d6bc10c80001bc772ca55abcd56cc8120cbb5/fvm/src/kernel/default.rs#L574",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("batch_verify_seals")]),o("OutboundLink")],1),e._v(":")]),e._v(" "),o("ol",[o("li",[e._v("which then calls "),o("a",{attrs:{href:"https://github.com/filecoin-project/ref-fvm/blob/146d6bc10c80001bc772ca55abcd56cc8120cbb5/fvm/src/kernel/default.rs#L1137",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("verify_seal")]),o("OutboundLink")],1),e._v(" "),o("ol",[o("li",[e._v("which then calls "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/1680ad08f607512e0c2f9d13c330d07f2b2ca081/storage-proofs-core/src/compound_proof.rs#L140",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("CompoundProof::verify")]),o("OutboundLink")],1),e._v(" to verify the proof for a single sector.\n"),o("ol",[o("li",[e._v("For a single partition proof, "),o("a",{attrs:{href:"https://github.com/filecoin-project/bellperson/blob/950829bba6504a806958877451480ef597d6bd73/src/groth16/verifier.rs#L38",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("verify_proof")]),o("OutboundLink")],1),e._v(" is called for verification.")]),e._v(" "),o("li",[e._v("For multiple partition proofs, a "),o("a",{attrs:{href:"https://github.com/filecoin-project/bellperson/blob/950829bba6504a806958877451480ef597d6bd73/src/groth16/verifier.rs#L137",target:"_blank",rel:"noopener noreferrer"}},[e._v("combining technique"),o("OutboundLink")],1),e._v(" is used to do batch verification.")])])])])])]),e._v(" "),o("h2",{attrs:{id:"snapdeal"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#snapdeal"}},[e._v("#")]),e._v(" SnapDeal")]),e._v(" "),o("p",[e._v("About why it's more efficient than re-sealing:")]),e._v(" "),o("ol",[o("li",[o("code",[e._v("tree_c")]),e._v(" is "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/32c7f7f22ef74d10503c6a4f722c2f5d436cd7fb/storage-proofs-update/src/vanilla.rs#L422-L425",target:"_blank",rel:"noopener noreferrer"}},[e._v("reused"),o("OutboundLink")],1),e._v(", so the heaviest step of label calculation is avoided.")]),e._v(" "),o("li",[o("code",[e._v("tree_d")]),e._v(" is re-calculated from scratch.")]),e._v(" "),o("li",[o("code",[e._v("tree_r_last")]),e._v(" is updated, each leave is updated according to "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/32c7f7f22ef74d10503c6a4f722c2f5d436cd7fb/storage-proofs-update/src/vanilla.rs#L444-L450",target:"_blank",rel:"noopener noreferrer"}},[e._v("this formula"),o("OutboundLink")],1),e._v(".\n"),o("ol",[o("li",[e._v("Decoding is a "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-fil-proofs/blob/32c7f7f22ef74d10503c6a4f722c2f5d436cd7fb/storage-proofs-update/src/vanilla.rs#L1049",target:"_blank",rel:"noopener noreferrer"}},[e._v("reverse"),o("OutboundLink")],1),e._v(" of this process.")]),e._v(" "),o("li",[e._v("Encoding is implemented by "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/4aa0112d10fe55370386871b5e862ca533f3aafe/src/update.rs#L52",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("empty_sector_update_encode_into")]),o("OutboundLink")],1),e._v(", corresponding proof is generated by "),o("a",{attrs:{href:"https://github.com/filecoin-project/rust-filecoin-proofs-api/blob/4aa0112d10fe55370386871b5e862ca533f3aafe/src/update.rs#L276",target:"_blank",rel:"noopener noreferrer"}},[o("code",[e._v("generate_partition_proofs")]),o("OutboundLink")],1),e._v(".")])])])])])}),[],!1,null,null,null);r.default=a.exports}}]);